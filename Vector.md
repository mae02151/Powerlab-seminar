#  Vector
### Vector 생성
```
- vector 생성
>> x=[1, 2, 3, 4, 5]
 x= 1 2 3 4 5

- vector의 크기 확인하기
length(A) A는 여기서 벡터
>> x = [1, 2, 3, 4, 5]
x = 1 2 3 4 5
>> size = length(x)
size = 5 

- 클론 연산자를 이용하여 행벡터 생성하기
ex) A = [a:m:b] or A = a:m:b (a:시작값, m:증가치 또는 감소치 , b: 최종값)
주의! 
1) m = 0인경우 행벅터가 정의되지 않고 빈 벡터가 된다.
2) m>0이고 a보다 ㅠ의 값이 작은 경우엔 행벡터가 정의 되지않고 빈 벡터가 생성
3) m<0이고 a보다 b의 값이 큰 경우에는 행벡터가 정의 되지않고 빈 벡터 생성

>> x = [2:5:30]
 x = 2 7 12 22 27
 
>> y = 0.1: -0.2: -1
y = 0.1000 -0.100 -0.300 -0.500 -0.700 -0.900

>> z =-3:3
z = -3 -2 -1 0 1 2 3

- 오류가 나는 케이스

>>x = [3:0]
x = ?

>> y = [4:0:9}
y = ?

>>z = [10:2:5]
z = ?

>> w = [2:-3:10]
w = ?

- linespace 명령어
ex) A = linspace(a, b, n) (a:첫번째 원소 b: 마지막 원소, n: 원소의 개수(*n 생략시 기본 설정값으로 100이 들어간다))
# 증감값을 지정하는 대신, 지정된 개수의 원소가 동일한 간격을 갖는 선형적인 형태의 행벡터를 생성하고 싶을때 사용
간격은 (b-a)/(n-1)이다.

>>x = linspace(2, 10, 5)
x = 2 4 6 8 10

>>y = linspace(-2, -10, 5)
y = -2 -4 -6 -8 -10

- m 생략해보기

>>z = linespace(1,100)
z = ?

- logspace 명령어 
ex) A = logspace(a, b, n)
위의 명령어와 기능은 동일하다. 단 상용로그 값을 가진 행벡터를 생성한다.

>>x = logspace(1,2,3)
x = 10.000 31.622 100.000

>>y = log10(x)
y = 1.000 1.5000 2.000

- 열 벡터 생성하기

>>x =[2; 9; 6; 17]
x = 
        2
        9
        6
        7
        
>>y =[5
-5
20
9]

y=
        5
        -5
        20
        9
```

### 벡터의 인덱싱(indexing)
- A(k) 단 c++ 이나 다른 언어들은 시작이 0 1 2..인 방면 매트랩에서는 시작이 1부터 이다 ( 1<=k<=n)

##### 값 참조(reference)
- R-value 로 사용되면 값을 의미 
       
       ex) x = A(2), A의 행렬 두번째 값을 가져와 x에 대입해서 R-value로 사용됨(값으로 사용됨).

##### 재할당(reassignment)
- L-value 로 사용되면 저장소의 위치 의미

       ex) A(30) = 30, A(30)의 위치를 가져와서 30을 대입하므로 L-value로 사용됨(위치 값이 사용됨). 

#### 행벡터 인덱싱하기
- 한개의 원소 인덱싱하는 경우
```
 1) 자연수
>> A = [4 -28, 6, 12, -2];
>> x = A(2)
x = -28

>> A(2) = 39
A = 4 39 6 12 -2

 2) 스칼라 변수 
>>A = [4 -28 6 12 -2];
>>x = 4;
>>A(x-2) = A(x)
 
 A =    4       12      6       12      -2
 
 3) end 키워드 사용하기 (마지막 위치 값 가져올 때 end 키워드 사용)
 
>>A = [4 -28 6 12 -2];
>>x = 4;
>> A(end) = A(end-4)
 
 A =    4       -28     6       12      4
 
 4) 명령어식
 
>>A = [4 -28 6 12 -2];
>>x = A(A(1))
 
 x = 12
 
>>y = A(end)
 
 y = -2
 
>>A(length(A))=A(end)*2

A =     4       -28     6       12      -4

```

- 여러 개의 원소를 인덱싱하는 경우
```
1) 콜론 연산자를 이용한 벡터의 인덱싱
 ex) A(a:m:b) (m이 정의되지 않으면 m값을 디폴트 값인 1로 정의한다)
 
 >>A = [4 -28 6 12 -2];
 >> x = A(1:2:end)
 
 x =    4       6       -2
 
 >>A(2:4) = 10
 A =    4       10      10      10      -2
 
 >>A(1:2:length(A)) = [20 40 60]
 
 A =    20      10      40      10      60
 
 2) 콜론 연산자를 이용한 모든원소 인덱싱
  ex) A(:) 소괄호 안에 콜론(:)만 넣은 경우 그 벡터의 모든 원소가 열 벡터로 인덱싱이 됨.

>>A = [4 -28 6 12 -2];
>>y = A(:)

y = 
        20
        10
        40
        10
        60

- 난이도 있는 문제
>>A = [3; 6; -3; 7];
>>B = [4 , 10, 9, 5, 17]
>>A(2:2:end)=]B(end-1) B(2)]

A = ?





















A = 
        3
        5
        -3
        10
        
>>B(1:length(A)) = A(:)

B =     3       5       -3      10      17

 3) 벡터를 이용한 벡터의 인덱싱

>>A = [2 4 5];
>>B = [4 -28 6 12 -2];
>>x = B(A)

x =     -28     12      -2

>>B(A) = 10

B =     4       10      6       10      10

```


#### 벡터의 확장과 축소
 - A(k)가 L-value로 사용되면 벡터 A의 k번째 값을 재 할당할 수 있다.
 - 벡터의 크기를 넘는 위치에 값을 할당할 수 있는데 이 경우를 벡터의 확장이라고 한다.
 - 예로 A = [1 2 3 4 5]에다가 A(8) = 9를 실행하면 A = [1 2 3 4 5 0 0 0 9] A(6) A(7) A(8) 부분은 모두 0으로 채워진다.
 
 ##### 벡터 확장
 ```
>>A = [4 -28 6 12 -2]
>>A(8) = 9
 
A =    4       -28     6       12      -2      0       0       9
 
>>B(4) = 38

B =     0       0       0       38

```
##### 콜론 연산자 이용한 벡터 확장
 - A(a:m:b) = 값 또는 벡터 
 
```
>>A(2) = 13

A =     0       13

>>A(6) = 17

A =     0       13      0       0       0       17

>>B[4 1 -8];
>>B(5) = A(end)

B =     4       1       -8      0       17

>>B(8:10)=B(1:2:5)

B =     4       1       -8      0       17      0       0       4       -8      17
```

#### 벡터 원소 삭제와 크기 축소
 - 크기가 n인 벡터 A에 대해 원소를 삭제해 백터의 크기를 축소할 수 있다.
 - A(k)를 L-value로 지정하고 [ ]를 사용하여 원소를 삭제해 벡터를 축소한다.
 
        ex) A(k) = [ ]
        
 - 콜론을 사용하여 축소가 가능하다.
 
        ex) A(a:m:b) = [ ]
  
  ##### 예제
  ```
 >>A = [2 12 8 -3 27 1];
 >>A(4) = [ ]
 
 A =    2       12      8       27      1
 
 - 콜론 사용
 >>A(1:3:end) = [ ]
 
 A =    12      8       1
 
 >>A(4:5) = [ ] 실행해보기!!
 
  ```
  
